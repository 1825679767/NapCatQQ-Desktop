# -*- coding: utf-8 -*-
"""
## 这个模块是用于更好的启动NC
"""
import ctypes
import shutil
import textwrap
from string import Template

import httpx
import psutil
from PySide6.QtCore import QObject, QThread, Signal
from creart import it
from loguru import logger

from src.Core.NetworkFunc import Urls
from src.Core.PathFunc import PathFunc


class BootWayUtils(QObject):

    def __init__(self) -> None:
        super().__init__()

    @staticmethod
    def getWay03JSCode() -> str:
        """
        ## 此方法用于储存 BootWay03 修补使用的 js 代码
            - 自动生成 js 代码并返回
        """
        logger.info(f"{'-' * 10} 开始生成 JS 代码 {'-' * 10}")
        template = Template(
            "// Generated by NapCat Desktop BootWay03\n"
            "const hasNapcatParam = process.argv.includes('--enable-logging');\n"
            "if (hasNapcatParam) {\n"
            "    (async () => {\n"
            "        await import('$NapCatPath');\n"
            "    })();\n"
            "} else {\n"
            "    require('./launcher.node').load('external_index', module);\n"
            "}\n"
        )
        path = "file://{}".format(str(it(PathFunc).getNapCatPath() / 'napcat.mjs').replace('\\', '//'))
        jsCode = textwrap.dedent(template.substitute(NapCatPath=path).strip())
        logger.info(f"\n{jsCode}")
        logger.info(f"{'-' * 10} 成功生成 JS 代码 {'-' * 10}")
        return jsCode

    @staticmethod
    def getWay05JSCode() -> str:
        """
        ## 此方法用于储存 BootWay05 修补使用的 js 代码
        :return:
        """
        logger.info(f"{'-' * 10} 开始生成 JS 代码 {'-' * 10}")
        template = Template(
            "// Generated by NapCat Desktop BootWay05\n"
            "(async () => {\n"
            f"    await import('$NapCatPath');\n);"
            "})();"
        )
        path = "file://{}".format(str(it(PathFunc).getNapCatPath() / 'napcat.mjs').replace('\\', '//'))
        jsCode = textwrap.dedent(template.substitute(NapCatPath=path).strip())
        logger.info(f"\n{jsCode}")
        logger.info(f"{'-' * 10} 成功生成 JS 代码 {'-' * 10}")
        return jsCode

    @staticmethod
    def killQQ() -> None:
        """
        ## 干掉 QQ 的进程
        """
        try:
            logger.info(f"{'-' * 10} 开始干掉 QQ {'-' * 10}")
            for proc in psutil.process_iter():
                # 遍历进程
                if proc.name() != "QQ.exe":
                    proc.kill()
                    logger.info(f"成功杀死 QQ({proc.pid}) 进程")

            logger.info("没有报错, 就当杀完了!")
        except Exception as e:
            logger.error(f"做掉 QQ 的过程中发生了错误: {e}")


class Way03(QThread):
    """
    ## Way03 修补 QQ 的操作(破坏性极强!!!!)
        - 此操作需要管理员权限写入修补文件
        - 此操作需要联网获取最新版修补文件
    """
    # 结束信号
    fixFinish = Signal()
    errorFinsh = Signal()

    def __init__(self) -> None:
        """
        ## 初始化类
            - utils 类中所需工具集
        """
        super().__init__()
        self.utils = BootWayUtils()

    def run(self) -> None:
        try:
            logger.info(f"{'-' * 10} BootWay 03 {'-' * 10}")
            if not ctypes.windll.shell32.IsUserAnAdmin():
                logger.error("非管理员模式运行,取消修补")
                self.errorFinsh.emit()

            # 首先结束 QQ 进程
            self.utils.killQQ()

            # 开始修改 QQ 的 index.js文件
            with open(str(it(PathFunc).getQQIndexPath()), "w", encoding="utf-8") as f:
                f.write(self.utils.getWay03JSCode())
                logger.info(f"修改 {it(PathFunc).getQQIndexPath()} 成功!")

            # 下载修补文件 DLLHijackMethod
            # 仓库地址: https://github.com/LiteLoaderQQNT/QQNTFileVerifyPatch/
            with open(str(it(PathFunc).getQQPath() / "dbghelp.dll"), "wb") as f:
                f.write(httpx.get(Urls.QQ_FIX_64.value.url()).content)
                logger.info(f"下载并写入 dbghelp.dll 成功")

            self.fixFinish.emit()

            logger.info(f"{'-' * 10} BootWay 03 {'-' * 10}")
        except (httpx.RequestError, httpx.HTTPStatusError, FileNotFoundError, PermissionError) as e:
            logger.error(f"BootWay 03 引发 {type(e).__name__}: {e}")
            self.errorFinsh.emit()


class Way05(QThread):
    """
    ## Way05 修补 QQ 的操作(破坏性较小!)
        - 此操作需要管理员权限写入修补文件
    """
    # 结束信号
    fixFinish = Signal()
    errorFinsh = Signal()

    def __init__(self) -> None:
        """
        ## 初始化
        """
        super().__init__()
        self.utils = BootWayUtils()

    def run(self) -> None:
        try:
            logger.info(f"{'-' * 10} BootWay 05 {'-' * 10}")
            if not ctypes.windll.shell32.IsUserAnAdmin():
                logger.error("非管理员模式运行,取消修补")
                self.errorFinsh.emit()

            # 还是先结束 QQ 进程
            self.utils.killQQ()

            # 生成一份 JS 在 NapCat Desktop 脚本目录下
            with open(str(it(PathFunc).getStartScriptPath() / "Way05LoadScript.js"), "w", encoding="utf-8") as f:
                f.write(self.utils.getWay05JSCode())

            # 复制 NapCat 目录下的修补文件到 QQ 目录
            shutil.copy2(it(PathFunc).getNapCatPath() / "dbghelp.dll", it(PathFunc).getQQPath() / "dbghelp.dll")

            self.fixFinish.emit()

            logger.info(f"{'-' * 10} BootWay 05 {'-' * 10}")
        except (httpx.RequestError, httpx.HTTPStatusError, FileNotFoundError, PermissionError) as e:
            logger.error(f"BootWay 03 引发 {type(e).__name__}: {e}")
            self.errorFinsh.emit()
